"""
Basic classes for hlib functionality.

@newfield default: Default
"""

__author__		= 'Milos Prchlik'
__copyright__		= 'Copyright 2010 - 2012, Milos Prchlik'
__contact__		= 'happz@happz.cz'
__license__		= 'http://www.php-suit.com/dpl'
__version__		= '3.0-rc1'

import ConfigParser
import htmlentitydefs
import os.path
import random
import re
import sys
import threading
import time
import traceback
import types

__version__ = '3.0-rc1'
"""
Library version tag

@type:				C{string}
"""

class Config(object):
  """
  Simple object, inherited from basic L{object}, used for "object-tree" style of configuration variables, with L{hlib.config} as root.
  """

  def dump(self, prefix):
    """
    Print all non-internal attributes of this object. If attribute is L{Config} child dump its attributes too (viva la recursion!)

    @type prefix:		C{string}
    @param prefix:		Path of names (joined by dot) that leads to this object.
    """

    for n in dir(self):
      if n in ['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'dump']:
        continue

      v = getattr(self, n)
      if v.__class__ == self.__class__:
        v.dump(prefix + '.' + n)
      else:
        print '%s.%s = "%s"' % (prefix, n, v)

config = {}

# pylint: disable-msg=W0201
PATH = os.path.dirname(__file__)

def url(path = None):
  return 'http://' + hruntime.request.base + path

def ips_to_str(ips):
  return ':'.join([str(ip) for ip in ips])

class ConfigFile(ConfigParser.ConfigParser):
  def __init__(self, default = None):
    ConfigParser.ConfigParser.__init__(self)

    self.default = default or {}

  def get(self, section, option):
    if self.has_option(section, option):
      return ConfigParser.ConfigParser.get(self, section, option)

    if section not in self.default:
      raise ConfigParser.NoSectionError(section)

    if option not in self.default[section]:
      raise ConfigParser.NoOptionError(section, option)

    return self.default[section][option]

class Runtime(threading.local):
  """
  Module-like wrapper for thread-local and request-specific variables. This module can be imported as C{hruntime}.

  @type tid:			C{int}
  @ivar tid:			Thread identifier, as returned by L{thread.get_ident}
  @type stats:			C{dict}
  @ivar stats:			Shortcut for L{hlib.stats.stats}.
  @type user:			C{hlib.datalayer.User}
  @ivar user:			Current user if known, C{None} otherwise.
  @type db:			L{hlib.database.DB}
  @ivar db:			Database object as passed to application.
  @type dbconn:			C{None}
  @ivar dbconn:			Current database connection. No need to use it.
  @type dbroot:			L{hlib.datalayer.Root}
  @ivar dbroot:			Database root - root of object tree stored in ZODB.
  @type root:			L{hlib.handlers.GenericHandler}
  @ivar root:			Handler root - root of object tree of handlers.
  @type server:			L{hlib.datalayer.Server}
  @ivar server:			Server-specific data stored in database.
  @type dont_commit:		C{bool}
  @ivar dont_commit:		If set to C{True} current transaction will be rolled back. Set to C{True} in case of error or when executing read-only method.
  @type ui_form:		C{string}
  @ivar ui_form:		ID of HTML form that is being generated by four templating library (C{w_form_*} functions)
  @type app:			L{hlib.engine.Application}
  @ivar app:			Application current request belongs to.
  @type request:		L{hlib.engine.Request}
  @ivar request:		Current request.
  @type response:		L{hlib.engine.Response}
  @ivar response:		Response for current request.
  @type session:		L{hlib.http.session.Session}
  @ivar session:		Initialized Session object, with all stored data loaded, if there is session available. C{None} otherwise.
  @type time:			C{int}
  #ivar time:
  @type localtime:		C{int}
  @ivar localtime:		
  @type cache:			L{hlib.cache.Cache}
  @ivar cache:
  """

  def reset_locals(self):
    """
    Set all properties of this module to C{None}.
    """

    for p in self.properties:
      setattr(self, p, None)

    self._stamp = None

  def __init__(self, *properties):
    """
    @type properties:			C{list} of C{string}s
    @param properties:		List of names of properties this module holds. Properties that are handled by C{__getattr__}/C{__setattr__} method are NOT included.
    """

    if self.__init_done == True:
      raise SystemError('__init__ called too many times')

    # pylint: disable-msg=W0233
    threading.local.__init__(self)

    self.properties = properties

    self.reset_locals()

    self.__init_done = True

  def __getattr__(self, name):
    if name == 'localtime':
      return time.localtime(self.time)

    if name == 'cache':
      return self.app.cache

    # pylint: disable-msg=W0212
    if name == 'time':
      if not hasattr(self, 'stamp') or self._stamp == None:
        self._stamp = int(time.time())

      return self._stamp

  def __setattr__(self, name, value):
    if name == 'time':
      # pylint: disable-msg=W0212
      self._stamp = None
      return

    threading.local.__setattr__(self, name, value)

  def clean(self):
    self.user			= None
    self.dont_commit		= False
    self.ui_form		= None
    self.time			= None

sys.modules['hruntime'] = Runtime('__init_done', 'tid', 'stats', 'user', 'db', 'dbconn', 'dbroot', 'root', 'server', 'dont_commit', 'ui_form', 'app', 'request', 'response', 'session', 'i18n')

# pylint: disable-msg=F0401
import hruntime

EVENTS = {}
"""
Allocated names of events. Key is event' name, value is corresponding class.
"""

def register_event(cls):
  """
  Register new event class.

  @type cls:			L{hlib.events.Event} class.
  @param cls:			Class responsible for handling this event.
  """

  # pylint: disable-msg=W0621
  import hlib.events
  EVENTS[hlib.events.ename(cls)] = cls

def unescape(text):
  def fixup(m):
    text = m.group(0)
    if text[:2] == "&#":
      try:
        if text[:3] == "&#x":
          return unichr(int(text[3:-1], 16))
        else:
          return unichr(int(text[2:-1]))
      except ValueError:
        pass
    else:
      try:
        text = unichr(htmlentitydefs.name2codepoint[text[1:-1]])
      except KeyError:
        pass
    return text
  return re.sub("&#?\w+;", fixup, text)
